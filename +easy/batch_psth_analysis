%% BATCH ANALYSIS OF KERNEL DENSITY ESTIMATION FOR PSTH
% This script loops through all channels in a recording. For each channel,
% it generates a single 2x2 figure that includes:
% 1. A spike raster plot.
% 2. The h-coefficient diagnostic plot (response vs. shuffled baseline).
% 3. The smoothed PSTH with key metrics (AUC, Peak FR).
% 4. The adaptive kernel bandwidth over time.
% All metrics are saved into a single aggregate struct.

clear; clc;

%% --- USER PARAMETERS ---
spikeFile = 'OWT220207_1H_DIV57_HUB45_3UA_Cspikes_L0_RP2.mat_Nortefact.mat';
rawFile   = 'OWT220207_1H_DIV57_HUB45_3UA.mat';
fs = 25000;
spikeMethod = 'bior1p5';
numChannels = 60;
artifact_window_ms = [0, 2];
psth_window_s = [0, 0.02];
psth_bin_width_s = 0.001;

%% --- CHANNEL REMAPPING & SETUP ---
indices = [24 26 29 32 35 37, 21 22 25 30 31 36 39 40, 19 20 23 28 33 38 41 42, 16 17 18 27 34 43 44 45, 15 14 13 4 57 48 47 46, 12 11 8 3 58 53 50 49, 10 9 6 1 60 55 52 51, 7 5 2 59 56 54];
ids = [21 31 41 51 61 71, 12 22 32 42 52 62 72 82, 13 23 33 43 53 63 73 83, 14 24 34 44 54 64 74 84, 15 25 35 45 55 65 75 85, 16 26 36 46 56 66 76 86, 17 27 37 47 57 67 77 87, 28 38 48 58 68 78];
channelMap = containers.Map('KeyType','double','ValueType','double');
for i = 1:numel(indices), channelMap(indices(i)) = ids(i); end
timestamp = datestr(now, 'ddmmmyyyy_HH:MM');
outputDir = ['PSTHanalysis(' timestamp ')'];
if ~exist(outputDir, 'dir'), mkdir(outputDir); end
fprintf('Saving analysis plots to folder: %s\n', outputDir);

%% --- LOAD DATA & FIND STIMS ---
fprintf('Loading and processing data...\n');
S = load(spikeFile);
if isfield(S, 'spikeTimes'), spikeTimesConverted = S.spikeTimes;
elseif isfield(S, 'spikes'), fprintf('Converting ''spikes'' matrix...\n');
    [row, col] = find(S.spikes); spikeTimesConverted = cell(1, numChannels);
    for ch = 1:numChannels, spike_samples = row(col == ch); spike_sec = spike_samples / fs; spikeTimesConverted{ch} = struct(spikeMethod, spike_sec); end
else, error('Spike data not found.'); end
R = load(rawFile);
if isfield(R, 'dat'), dat = double(R.dat); else, error('Raw data not found.'); end
[num_samples, ~] = size(dat); stimThreshold = -1000; min_interval_ms = 2500; flat_search_window_ms = 100; flat_window_ms = 1.5; flat_thresh = 0.05;
flat_window_samples = round(flat_window_ms * fs / 1000); flat_search_samples = round(flat_search_window_ms * fs / 1000); stim_times_sec = [];
for channel_idx = 1:numChannels, trace = dat(:, channel_idx); idx = find(trace > stimThreshold); if isempty(idx), continue, end; idx = idx(:);
    keep = [true; diff(idx) > round(0.010 * fs)]; idx = idx(keep);
    for i = 1:length(idx), center_idx = idx(i); win_start = max(1, center_idx - flat_search_samples); win_end = min(num_samples, center_idx + flat_search_samples);
        win_trace = trace(win_start:win_end); abs_diff = [0; abs(diff(win_trace))]; mov_abs_diff = movmean(abs_diff, flat_window_samples);
        flat_idx = find(mov_abs_diff < flat_thresh);
        if ~isempty(flat_idx), flat_onsets = flat_idx([true; diff(flat_idx) > 1]); flat_onsets_adj = flat_onsets - floor(flat_window_samples/2); flat_onsets_adj(flat_onsets_adj < 1) = 1;
            if ~isempty(flat_onsets_adj), keep_idx = [true; diff(flat_onsets_adj) > round(min_interval_ms * fs / 1000)]; flat_onsets_adj = flat_onsets_adj(keep_idx); end
            for j = 1:length(flat_onsets_adj), stim_idx = win_start - 1 + flat_onsets_adj(j); stim_times_sec = [stim_times_sec; stim_idx / fs]; end
        end; end; end
stimTimes = sort(unique(stim_times_sec(:)));
fprintf('Found %d stimulation events.\n', length(stimTimes));

%% --- STEP 2: LOOP THROUGH CHANNELS FOR ANALYSIS ---
networkResponse = [];
valid_channel_count = 0;
for file_idx = 1:numChannels
    if ~isKey(channelMap, file_idx), continue; end
    channel_id = channelMap(file_idx);
    fprintf('\n--- Processing File Index %d (Channel ID %d) ---\n', file_idx, channel_id);

    if file_idx > numChannels || file_idx < 1 || isempty(spikeTimesConverted{file_idx}) || ~isfield(spikeTimesConverted{file_idx}, spikeMethod), all_spike_times_s = [];
    else, all_spike_times_s = spikeTimesConverted{file_idx}.(spikeMethod); end
    if isempty(all_spike_times_s), fprintf('No spikes found. Skipping.\n'); continue; end
    
    spikeTimes_cleaned_s = all_spike_times_s;
    for stimIdx = 1:numel(stimTimes), stimTime = stimTimes(stimIdx);
        spikeTimes_cleaned_s = spikeTimes_cleaned_s(spikeTimes_cleaned_s < (stimTime + artifact_window_ms(1)/1000) | spikeTimes_cleaned_s >= (stimTime + artifact_window_ms(2)/1000));
    end
    spikeTimes_cleaned_s = sort(spikeTimes_cleaned_s(:));

    out = WithinRanges(spikeTimes_cleaned_s, stimTimes + psth_window_s, (1:length(stimTimes))', 'matrix');
    spikeTimes_byEvent = arrayfun(@(n) spikeTimes_cleaned_s(logical(out(:,n))) - stimTimes(n), 1:length(stimTimes), 'uni', 0)';
    psth_samples = cell2mat(spikeTimes_byEvent);

    if isempty(psth_samples), fprintf('No spikes in PSTH window. Skipping.\n'); continue; end
    fprintf('Processing %d spikes from Channel ID %d.\n', length(psth_samples), channel_id);

    %% --- H-COEFFICIENT CALCULATION ---
    fprintf('Calculating h-coefficient...\n');
    [hcoeffs, hcoeffs2D, ~, bslshuff] = hcoeff_wrapper(spikeTimes_byEvent, all_spike_times_s, psth_window_s);
    fprintf('h-coeff (max/min): %.2f / %.2f\n', hcoeffs(1), hcoeffs(2));

    %% --- CONSOLIDATED 2x2 PLOT GENERATION ---
    fig = figure('Position',[100 100 1200 900], 'Visible', 'off');
    psth_window_ms = psth_window_s * 1000;
    
    % Add a main title for the entire figure
    sgtitle(sprintf('Channel %d Analysis | h-coeff (max/min): %.2f / %.2f', channel_id, hcoeffs(1), hcoeffs(2)), 'FontWeight', 'bold');

    % --- Plot 1: Raster Plot ---
    ax1 = subplot(2,2,1);
    hold on;
    for trial_idx = 1:length(spikeTimes_byEvent)
        trial_spikes_s = spikeTimes_byEvent{trial_idx};
        if ~isempty(trial_spikes_s)
            plot(trial_spikes_s * 1000, trial_idx * ones(size(trial_spikes_s)), 'r.', 'MarkerSize', 5);
        end
    end
    hold off;
    set(gca, 'YDir', 'reverse'); 
    xlim(psth_window_ms);
    ylim([0 length(spikeTimes_byEvent)+1]);
    ylabel('Trial Number');
    title('Spike Raster');
    grid on;

    % --- Plot 2: H-Coefficient Diagnostic Plot ---
    ax2 = subplot(2,2,2);
    hold on;
    if ~isempty(bslshuff)
        % Plot all the shuffled baseline kernels in gray
        for i = 1:length(bslshuff.kern)
            plot(bslshuff.kern{i}(1,:)*1000, bslshuff.kern{i}(2,:), 'Color', [0.8 0.8 0.8], 'HandleVisibility', 'off');
        end
    end
    % Calculate smoothed PSTH for plotting
    L = 1000; t_s = linspace(psth_window_s(1), psth_window_s(2), L);
    [yv_pdf, tv_s, optw_variable_s] = ssvkernel(psth_samples, t_s);
    num_trials = length(stimTimes);
    avg_spikes_per_trial = length(psth_samples) / num_trials;
    yv = yv_pdf * avg_spikes_per_trial;
    % Plot the actual response kernel in red
    p1_diag = plot(tv_s*1000, yv, 'r-', 'LineWidth', 2);
    p2_diag = plot(NaN,NaN,'Color',[0.8 0.8 0.8],'LineWidth',2); % Dummy plot for legend
    hold off;
    title('H-Coeff Diagnostic');
    ylabel('Firing Rate (spikes/s)');
    legend([p1_diag, p2_diag], 'Response', 'Baseline', 'Location', 'Best');
    grid on;

    % --- Plot 3: Smoothed PSTH and Metrics ---
    ax3 = subplot(2,2,3);
    hold on;
    % Raw histogram bars
    edges_s = psth_window_s(1):psth_bin_width_s:psth_window_s(2);
    b = histc(psth_samples, edges_s);
    bar(edges_s * 1000, b / (num_trials * psth_bin_width_s), 1, 'FaceColor',.7*[1 1 1],'EdgeColor',.8*[1 1 1], 'HandleVisibility','off');
    % Smoothed PSTH
    plot(tv_s * 1000, yv, 'r-', 'LineWidth', 2);
    % Metrics calculation and plotting
    auc = trapz(tv_s, yv);
    [max_fr, max_idx] = max(yv);
    max_time_s = tv_s(max_idx);
    plot(max_time_s * 1000, max_fr, 'ko', 'MarkerFaceColor', 'k', 'MarkerSize', 6, 'HandleVisibility','off');
    text(max_time_s * 1000, max_fr, sprintf(' Peak: %.1f Hz', max_fr), 'VerticalAlignment', 'bottom');
    plot_ylim = get(gca, 'YLim');
    text(psth_window_ms(1) + 2, plot_ylim(2)*0.9, sprintf('AUC: %.3f', auc), 'FontWeight', 'bold');
    hold off;
    ylabel('Firing Rate (spikes/s)');
    xlabel('Time from stimulus (ms)');
    title('Smoothed PSTH & Metrics');
    legend('Smoothed PSTH', 'Location', 'Best');
    grid on;

    % --- Plot 4: Kernel Bandwidth ---
    ax4 = subplot(2,2,4);
    plot(tv_s * 1000, optw_variable_s * 1000, 'b-', 'LineWidth', 2);
    ylabel('Bandwidth (ms)');
    xlabel('Time from stimulus (ms)');
    title('Adaptive Kernel Bandwidth');
    grid on;
    
    % --- Final Figure Adjustments ---
    linkaxes([ax1, ax2, ax3, ax4], 'x');
    xlim(psth_window_ms);

    plot_filename = fullfile(outputDir, sprintf('Analysis_Plot_Chan_%d.png', channel_id));
    saveas(fig, plot_filename);
    fprintf('Saved consolidated plot to %s\n', plot_filename);
    close(fig);

    %% --- SAVE RESULTS ---
    valid_channel_count = valid_channel_count + 1;
    networkResponse(valid_channel_count).channel_id = channel_id;
    networkResponse(valid_channel_count).file_index = file_idx;
    networkResponse(valid_channel_count).auc = auc;
    networkResponse(valid_channel_count).peak_firing_rate_hz = max_fr;
    networkResponse(valid_channel_count).peak_time_ms = max_time_s * 1000;
    networkResponse(valid_channel_count).h_coeff_max = hcoeffs(1);
    networkResponse(valid_channel_count).h_coeff_min = hcoeffs(2);
    networkResponse(valid_channel_count).h_coeff_2D = hcoeffs2D;
end

%% --- SAVE AGGREGATE RESULTS ---
if ~isempty(networkResponse)
    output_filename = sprintf('networkResponse_all_channels_%s.mat', timestamp);
    save(output_filename, 'networkResponse');
    fprintf('\nSaved aggregate network response metrics for %d channels to %s\n', valid_channel_count, output_filename);
else, fprintf('\nNo valid channels with spikes were found to save.\n'); end
fprintf('Script finished.\n');
